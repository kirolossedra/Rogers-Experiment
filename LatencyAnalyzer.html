<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Ping Analyzer ‚Äî RTT-based Jitter (Accurate)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  body{font-family:Arial,Helvetica,sans-serif;background:#f5f7fb;margin:20px}
  .container{max-width:1100px;margin:0 auto;background:#fff;padding:24px;border-radius:8px;box-shadow:0 6px 18px rgba(20,30,60,.06)}
  h1{margin:0 0 8px;font-size:22px;color:#1f2937}
  p.lead{color:#4b5563;margin-top:0}
  .upload{border:2px dashed #2563eb;border-radius:8px;padding:26px;text-align:center;background:#fbfdff;cursor:pointer}
  .upload.dragover{background:#e6f0ff;border-color:#1e40af}
  .controls{margin-top:14px;display:flex;gap:8px;flex-wrap:wrap}
  button{background:#2563eb;color:#fff;border:none;padding:10px 14px;border-radius:6px;cursor:pointer}
  button.secondary{background:#6b7280}
  button:disabled{opacity:.5;cursor:not-allowed}
  .file-list{margin-top:16px}
  .file-item{display:flex;justify-content:space-between;align-items:center;padding:8px 10px;border-radius:6px;background:#f8fafc;margin:6px 0}
  .result{margin-top:22px}
  .box{padding:14px;border-radius:8px;background:#f8fafc;margin-bottom:14px}
  .table-wrap{overflow-x:auto;margin-top:10px}
  table{width:100%;border-collapse:collapse}
  th,td{padding:8px;border:1px solid #e6eef8;text-align:left}
  th{background:#1e40af;color:#fff}
  .latex{background:#0f172a;color:#e6eef8;padding:12px;border-radius:6px;white-space:pre-wrap;font-family:monospace;font-size:13px;margin-top:8px}
  .small{font-size:13px;color:#374151}
  .tag{display:inline-block;padding:6px 8px;background:#e6f4ff;border-radius:999px;color:#0f172a;margin-right:6px;font-weight:600}
  .stat-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:12px;margin-top:12px}
  .stat{background:#fff;padding:12px;border-radius:8px;border:1px solid #eef2ff}
  .stat strong{display:block;font-size:18px}
  .warning{background:#fff7ed;border-left:4px solid #f59e0b;padding:10px;border-radius:6px}
</style>
</head>
<body>
<div class="container">
  <h1>Ping Analyzer ‚Äî RTT-based Jitter (Accurate)</h1>
  <p class="lead">Upload one or more ping log files (lines with timestamps and <code>icmp_seq=</code> and <code>time=</code>). This tool computes RTT-based jitter (|RTT‚Çô ‚àí RTT‚Çô‚Çã‚ÇÅ|) only for consecutive sequence numbers ‚Äî the correct approach when you only have ping RTTs.</p>

  <div class="upload" id="uploadArea">üìÇ Click or drag & drop ping log files here (format: <code>YYYY-MM-DD HH:MM:SS ... icmp_seq=N ... time=XX.X ms</code>)</div>
  <input id="fileInput" type="file" accept=".txt,.log,text/*" multiple style="display:none"/>

  <div class="file-list" id="fileList"></div>

  <div class="controls">
    <button id="analyzeBtn" disabled>Analyze Files</button>
    <button id="clearBtn" class="secondary" disabled>Clear</button>
  </div>

  <div class="result" id="result"></div>
</div>

<script>
/* ============================
   Utility functions
   ============================ */
function percentile(arr, p) {
  if (!arr || arr.length === 0) return 0;
  const s = arr.slice().sort((a,b)=>a-b);
  const idx = (p/100)*(s.length-1);
  const lo = Math.floor(idx), hi = Math.ceil(idx);
  const w = idx - lo;
  return s[lo]*(1-w) + s[hi]*w;
}
function mean(arr){
  if(!arr || arr.length===0) return 0;
  return arr.reduce((a,b)=>a+b,0)/arr.length;
}
function msFromDateStr(dateStr, timeStr){
  // dateStr: YYYY-MM-DD  timeStr: HH:MM:SS
  // create using ISO so Date parser is consistent
  return new Date(dateStr + 'T' + timeStr).getTime();
}
function safeToFixed(v, d=2){ return (isFinite(v) ? v.toFixed(d) : 'NaN'); }

/* ============================
   UI / File handling
   ============================ */
let uploadedFiles = [];
const uploadArea = document.getElementById('uploadArea');
const fileInput = document.getElementById('fileInput');
const fileListDiv = document.getElementById('fileList');
const analyzeBtn = document.getElementById('analyzeBtn');
const clearBtn = document.getElementById('clearBtn');
const resultDiv = document.getElementById('result');

uploadArea.addEventListener('click', ()=>fileInput.click());
uploadArea.addEventListener('dragover', (e)=>{ e.preventDefault(); uploadArea.classList.add('dragover'); });
uploadArea.addEventListener('dragleave', ()=>uploadArea.classList.remove('dragover'));
uploadArea.addEventListener('drop', (e)=>{ e.preventDefault(); uploadArea.classList.remove('dragover'); addFiles(Array.from(e.dataTransfer.files)); });

fileInput.addEventListener('change', (e)=>{ addFiles(Array.from(e.target.files)); fileInput.value = ''; });

function addFiles(files){
  files.forEach(f=>{
    if(!uploadedFiles.find(u=>u.name===f.name)) uploadedFiles.push(f);
  });
  renderFileList();
}
function removeFile(idx){ uploadedFiles.splice(idx,1); renderFileList(); }
function clearFiles(){ uploadedFiles=[]; renderFileList(); resultDiv.innerHTML=''; }

function renderFileList(){
  fileListDiv.innerHTML='';
  if(uploadedFiles.length===0){
    analyzeBtn.disabled=true; clearBtn.disabled=true;
    return;
  }
  uploadedFiles.forEach((f,i)=>{
    const el = document.createElement('div'); el.className='file-item';
    el.innerHTML = `<div><strong>${i+1}.</strong> ${f.name}</div>
      <div><button onclick="removeFile(${i})" class="secondary">Remove</button></div>`;
    fileListDiv.appendChild(el);
  });
  analyzeBtn.disabled=false; clearBtn.disabled=false;
}

/* ============================
   Parsing & Analysis
   ============================ */

// Regex expects lines like:
// 2025-11-13 11:01:09 64 bytes from 192.168.0.231: icmp_seq=10 ttl=64 time=57.7 ms
const PING_LINE_RE = /^(\d{4}-\d{2}-\d{2})\s+(\d{2}:\d{2}:\d{2}).*icmp_seq=(\d+).*time=([\d.]+)\s*ms/i;

function analyzePingText(text){
  const lines = text.split(/\r?\n/);
  const packets = []; // {seq, timestamp(ms), rtt(ms)}
  let minSeq = Infinity, maxSeq = -Infinity;

  for(const line of lines){
    const m = line.match(PING_LINE_RE);
    if(!m) continue;
    const date = m[1], time = m[2], seq = parseInt(m[3],10), rtt = parseFloat(m[4]);
    const ts = msFromDateStr(date, time); // timestamp in ms (arrival time)
    packets.push({seq, timestamp: ts, rtt});
    if(seq < minSeq) minSeq = seq;
    if(seq > maxSeq) maxSeq = seq;
  }

  if(packets.length===0) return null;

  // Sort by sequence number (handle logs out-of-order)
  packets.sort((a,b)=>a.seq - b.seq);

  // Build lookup and lost list
  const totalExpected = (maxSeq - minSeq + 1);
  const receivedCount = packets.length;
  const lostCount = totalExpected - receivedCount;
  const lostList = [];
  const seqSet = new Set(packets.map(p=>p.seq));
  for(let s=minSeq; s<=maxSeq; s++){
    if(!seqSet.has(s)) lostList.push(s);
  }
  const lostPercent = (lostCount / totalExpected) * 100;

  // Compute RTT-based jitter:
  // Use |RTT[n] - RTT[n-1]| but ONLY when seq difference == 1 (consecutive packets).
  const jitterDiffs = [];
  const jitterDiffs_all = []; // also keep diffs for any adjacent in array for diagnostics (not used by main avg)
  let prevPacket = null;
  let outOfOrder = 0;

  for(let i=0;i<packets.length;i++){
    const cur = packets[i];
    if(prevPacket){
      // detect out-of-order by seq (should not happen after sorting by seq, but if arrival ordering needed, adapt)
      if(cur.seq <= prevPacket.seq) outOfOrder++;
      // consecutive-seq check to avoid counting gaps caused by loss
      if(cur.seq === prevPacket.seq + 1){
        jitterDiffs.push(Math.abs(cur.rtt - prevPacket.rtt));
      }
      // for diagnostics keep also adjacent diffs (useful when user wants alternative)
      jitterDiffs_all.push(Math.abs(cur.rtt - prevPacket.rtt));
    }
    prevPacket = cur;
  }

  // RTT statistics
  const rtts = packets.map(p=>p.rtt);
  const minRtt = Math.min(...rtts);
  const maxRtt = Math.max(...rtts);
  const extremeCount = rtts.filter(t=>t>=1000).length;
  const extremePercent = (extremeCount / receivedCount) * 100; // relative to received packets

  // Jitter summary (only consecutive diffs)
  const avgJitter = jitterDiffs.length ? mean(jitterDiffs) : 0;
  const medJitter = percentile(jitterDiffs,50);
  const p75 = percentile(jitterDiffs,75);
  const p90 = percentile(jitterDiffs,90);
  const p95 = percentile(jitterDiffs,95);
  const p99 = percentile(jitterDiffs,99);
  const maxJitter = jitterDiffs.length ? Math.max(...jitterDiffs) : 0;

  // IQR-based separation
  const q1 = percentile(jitterDiffs,25), q3 = percentile(jitterDiffs,75);
  const iqr = q3 - q1;
  const lb = q1 - 1.5*iqr, ub = q3 + 1.5*iqr;
  const normalJ = jitterDiffs.filter(j => j >= lb && j <= ub);
  const spikes = jitterDiffs.filter(j => j < lb || j > ub);
  const normalJAvg = normalJ.length ? mean(normalJ) : 0;
  const spikeJAvg = spikes.length ? mean(spikes) : 0;
  const spikeRate = jitterDiffs.length ? (spikes.length / jitterDiffs.length) * 100 : 0;

  // threshold (3x median)
  const threshold = 3 * medJitter;
  const normalT = jitterDiffs.filter(j => j < threshold);
  const spikeT = jitterDiffs.filter(j => j >= threshold);
  const normalTavg = normalT.length ? mean(normalT) : 0;
  const spikeTavg = spikeT.length ? mean(spikeT) : 0;
  const spikeTRate = jitterDiffs.length ? (spikeT.length / jitterDiffs.length) * 100 : 0;

  return {
    packets,
    minSeq, maxSeq,
    totalExpected, receivedCount, lostCount, lostPercent, lostList,
    minRtt, maxRtt, extremeCount, extremePercent,
    outOfOrderCount: outOfOrder, outOfOrderPercent: (outOfOrder / packets.length) * 100,
    jitterDiffs, jitterDiffs_all,
    avgJitter, medJitter, p75, p90, p95, p99, maxJitter,
    normalJAvg, spikeJAvg, spikeRate,
    normalTavg, spikeTavg, spikeTRate,
    hasTimestamps: true
  };
}

/* ============================
   Display helpers
   ============================ */

function formatResultSummary(analysis){
  return `
    <div class="box">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div>
          <div class="tag">RTT jitter</div>
          <div class="small">Packets expected: <strong>${analysis.totalExpected}</strong> ¬∑ Received: <strong>${analysis.receivedCount}</strong> ¬∑ Lost: <strong>${analysis.lostCount}</strong> (${safeToFixed(analysis.lostPercent,2)}%)</div>
        </div>
        <div style="text-align:right">
          <div class="small">Min RTT / Max RTT</div>
          <div style="font-weight:700">${safeToFixed(analysis.minRtt,2)} ms / ${safeToFixed(analysis.maxRtt,2)} ms</div>
        </div>
      </div>

      <div class="stat-grid" style="margin-top:12px">
        <div class="stat"><small>Avg jitter (consecutive)</small><strong>${safeToFixed(analysis.avgJitter,2)} ms</strong></div>
        <div class="stat"><small>Median jitter</small><strong>${safeToFixed(analysis.medJitter,2)} ms</strong></div>
        <div class="stat"><small>99th percentile jitter</small><strong>${safeToFixed(analysis.p99,2)} ms</strong></div>
        <div class="stat"><small>Spike rate (IQR)</small><strong>${safeToFixed(analysis.spikeRate,2)} %</strong></div>
        <div class="stat"><small>Extreme RTTs ‚â• 1000 ms</small><strong>${analysis.extremeCount} (${safeToFixed(analysis.extremePercent,2)}%)</strong></div>
        <div class="stat"><small>Out-of-order</small><strong>${analysis.outOfOrderCount} (${safeToFixed(analysis.outOfOrderPercent,2)}%)</strong></div>
      </div>
    </div>
  `;
}

function makeHtmlTable(analysis){
  // small table showing jitter distribution and lost list
  const jitter = analysis.jitterDiffs.slice().sort((a,b)=>a-b);
  return `
    <div class="table-wrap">
      <table>
        <thead><tr>
          <th>Metric</th><th>Value</th>
        </tr></thead>
        <tbody>
          <tr><td>Avg jitter (consecutive)</td><td>${safeToFixed(analysis.avgJitter,2)} ms</td></tr>
          <tr><td>Median (50%)</td><td>${safeToFixed(analysis.medJitter,2)} ms</td></tr>
          <tr><td>75%</td><td>${safeToFixed(analysis.p75,2)} ms</td></tr>
          <tr><td>90%</td><td>${safeToFixed(analysis.p90,2)} ms</td></tr>
          <tr><td>95%</td><td>${safeToFixed(analysis.p95,2)} ms</td></tr>
          <tr><td>99%</td><td>${safeToFixed(analysis.p99,2)} ms</td></tr>
          <tr><td>Max jitter (consec.)</td><td>${safeToFixed(analysis.maxJitter,2)} ms</td></tr>
          <tr><td>Lost sequences</td><td>${analysis.lostList.length ? analysis.lostList.join(', ') : 'None'}</td></tr>
          <tr><td>Packets with RTT ‚â• 1000 ms</td><td>${analysis.extremeCount} (${safeToFixed(analysis.extremePercent,2)}% of received)</td></tr>
        </tbody>
      </table>
    </div>
  `;
}

function latexAggregateTable(name, analysis){
  // simple latex table for aggregate metrics
  return `\\begin{table}[htbp]
\\centering
\\caption{Ping analysis ‚Äî ${name}}
\\begin{tabular}{|l|r|}
\\hline
Metric & Value \\\\
\\hline
Packets expected & ${analysis.totalExpected} \\\\
Packets received & ${analysis.receivedCount} \\\\
Packets lost & ${analysis.lostCount} (${safeToFixed(analysis.lostPercent,2)}\\%) \\\\
Min RTT (ms) & ${safeToFixed(analysis.minRtt,2)} \\\\
Max RTT (ms) & ${safeToFixed(analysis.maxRtt,2)} \\\\
Avg jitter (ms) & ${safeToFixed(analysis.avgJitter,2)} \\\\
Median jitter (ms) & ${safeToFixed(analysis.medJitter,2)} \\\\
99th jitter (ms) & ${safeToFixed(analysis.p99,2)} \\\\
Extreme RTTs (>=1000 ms) & ${analysis.extremeCount} (${safeToFixed(analysis.extremePercent,2)}\\%) \\\\
Out-of-order & ${analysis.outOfOrderCount} (${safeToFixed(analysis.outOfOrderPercent,2)}\\%) \\\\
\\hline
\\end{tabular}
\\end{table}`;
}

/* ============================
   Wire analyze button
   ============================ */

analyzeBtn.addEventListener('click', async ()=>{
  resultDiv.innerHTML = '<div class="box small">Parsing files and computing statistics‚Ä¶</div>';
  const results = [];
  let hasAny = false;
  for(let i=0;i<uploadedFiles.length;i++){
    const f = uploadedFiles[i];
    try{
      const text = await f.text();
      const analysis = analyzePingText(text);
      if(analysis){
        results.push({fileName: f.name, analysis});
        hasAny = true;
      } else {
        results.push({fileName: f.name, error:true});
      }
    }catch(e){
      results.push({fileName: f.name, error:true});
    }
  }

  // Display
  let out = '';
  if(!hasAny){
    out = `<div class="warning">No valid ping lines found. Make sure logs include timestamps and <code>icmp_seq=</code> and <code>time=</code> fields (e.g. "2025-11-13 11:01:09 ... icmp_seq=10 ... time=57.7 ms").</div>`;
    resultDiv.innerHTML = out; return;
  }

  results.forEach((r, idx)=>{
    if(r.error){
      out += `<div class="box"><strong>${r.fileName}</strong> ‚Äî <span style="color:#b91c1c">No valid ping entries found</span></div>`;
      return;
    }
    const analysis = r.analysis;
    out += `<div class="box"><strong>${r.fileName}</strong></div>`;
    out += formatResultSummary(analysis);
    out += `<div class="box"><h3 style="margin:0 0 8px">Details</h3>` + makeHtmlTable(analysis) + `</div>`;
    out += `<div class="latex">${latexAggregateTable(r.fileName, analysis)}</div>`;
  });

  resultDiv.innerHTML = out;
});

/* ============================
   Wire clear button
   ============================ */
clearBtn.addEventListener('click', ()=>{ clearFiles(); });

/* Expose removeFile globally so inline onclick can call it (small helper) */
window.removeFile = removeFile;

</script>
</body>
</html>
