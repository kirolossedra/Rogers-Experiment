<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network Log Analyzer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: Arial, sans-serif; background: #1a1f2e; padding: 20px; }
        .container { max-width: 1400px; margin: 0 auto; background: #fff; border-radius: 8px; display: grid; grid-template-columns: 350px 1fr; min-height: 90vh; }
        .sidebar { background: #f5f7fa; padding: 20px; border-right: 1px solid #ddd; overflow-y: auto; }
        .main-content { padding: 20px; display: flex; flex-direction: column; overflow-y: auto; }
        h1 { font-size: 24px; margin-bottom: 20px; color: #2c3e50; }
        .section { margin-bottom: 20px; }
        .section-title { font-size: 13px; font-weight: 600; color: #2c3e50; margin-bottom: 8px; text-transform: uppercase; }
        input[type="text"], input[type="number"] { width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-size: 14px; }
        input[type="text"]:focus, input[type="number"]:focus { outline: none; border-color: #2c5282; }
        .drop-zone { border: 2px dashed #bbb; border-radius: 6px; padding: 25px; text-align: center; cursor: pointer; background: white; }
        .drop-zone:hover, .drop-zone.dragover { border-color: #2c5282; background: #edf2f7; }
        .drop-zone-small { padding: 15px; font-size: 13px; }
        .file-list { margin-top: 10px; max-height: 120px; overflow-y: auto; }
        .file-item { background: white; padding: 8px; margin: 5px 0; border-radius: 4px; font-size: 13px; display: flex; justify-content: space-between; border: 1px solid #ddd; }
        .file-item button { background: #c53030; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 12px; }
        .time-slices { max-height: 250px; overflow-y: auto; }
        .time-slice { display: flex; gap: 8px; margin-bottom: 8px; align-items: center; }
        .time-slice input { width: 75px; padding: 6px; font-size: 13px; }
        .time-slice .checklist { display: inline-flex; gap: 6px; }
        .time-slice .checklist label { font-size: 12px; }
        .time-slice button { background: #c53030; color: white; border: none; padding: 6px 10px; border-radius: 3px; cursor: pointer; }
        .time-slice.from-file { background: #e6f2ff; padding: 8px; border-radius: 4px; border-left: 3px solid #2c5282; }
        .time-slice.from-file .slice-label { font-size: 11px; color: #2c5282; font-weight: 600; }
        .btn { width: 100%; padding: 10px; border: none; border-radius: 4px; font-size: 14px; font-weight: 600; cursor: pointer; margin-top: 10px; }
        .btn-primary { background: #2c5282; color: white; }
        .btn-primary:hover { background: #2a4365; }
        .btn-secondary { background: #4a5568; color: white; }
        .status { padding: 10px; border-radius: 4px; font-size: 13px; margin-top: 10px; text-align: center; }
        .status.success { background: #c6f6d5; color: #22543d; }
        .status.error { background: #fed7d7; color: #742a2a; }
        .status.info { background: #bee3f8; color: #2c5282; }
        .plots-scroll-container { flex: 1; overflow-y: auto; padding-right: 10px; }
        .plot-item { background: #f5f7fa; border-radius: 6px; padding: 15px; margin-bottom: 15px; }
        .plot-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        .plot-title { font-size: 16px; font-weight: 600; color: #2c3e50; }
        .btn-group { display: flex; gap: 8px; }
        .export-btn { padding: 8px 16px; background: #38a169; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600; font-size: 13px; }
        .export-btn:hover { background: #2f855a; }
        .copy-btn { padding: 8px 16px; background: #3182ce; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600; font-size: 13px; }
        .copy-btn:hover { background: #2c5282; }
        .plot-canvas-wrapper { background: white; border-radius: 6px; padding: 15px; }
        .empty-state { text-align: center; color: #718096; font-size: 16px; padding: 60px 20px; background: #f5f7fa; border-radius: 6px; }
        canvas { max-width: 100%; height: 400px !important; }
        .results-header { font-size: 20px; font-weight: 600; color: #2c3e50; margin-bottom: 15px; }
        .mode-switch { margin-bottom: 25px; text-align: center; }
        .mode-switch label { font-size: 15px; font-weight: 600; margin-right: 10px; }
        .mode-switch select { padding: 5px 10px; font-size: 15px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <h1>üìä Log Analyzer</h1>
            <div class="mode-switch">
                <label for="mode">Mode:</label>
                <select id="mode">
                    <option value="iperf">Throughput (iperf)</option>
                    <option value="ping">Latency (ping)</option>
                    <option value="snr">Presence/SNR (MAC)</option>
                    <option value="all">All (Custom)</option>
                </select>
            </div>
            <div class="section" id="ipSec">
                <div class="section-title">Target IP</div>
                <input type="text" id="ip" value="192.168.0.201">
            </div>
            <div class="section" id="macSec" style="display:none;">
                <div class="section-title">Target MAC</div>
                <input type="text" id="mac" placeholder="fa:6a:95:eb:f0:57">
            </div>
            <div class="section">
                <div class="section-title"><span id="winLabel">Smoothing Window</span></div>
                <input type="range" id="win" min="1" max="20" value="1" style="width: 100%;">
                <div style="text-align: center; font-size: 12px; color: #4a5568; margin-top: 5px;">
                    Window: <span id="winVal">1</span> points
                </div>
            </div>
            <div class="section" id="logSec">
                <div class="section-title">Log Files</div>
                <div class="drop-zone" id="drop">
                    <div>üìÅ Drop .txt or .log files here<br><small>Your main experiment log file</small></div>
                    <input type="file" id="files" multiple accept=".txt,.log" style="display: none;">
                </div>
                <div class="file-list" id="fileList"></div>
            </div>
            <div class="section" id="sliceSec">
                <div class="section-title">Add Slices from File</div>
                <div class="drop-zone drop-zone-small" id="sliceDrop">
                    <div>üìÑ Drop iperf3/ping slice files<br><small>(extract time windows)</small></div>
                    <input type="file" id="sliceFiles" multiple accept=".txt,.log" style="display: none;">
                </div>
            </div>
            <div class="section">
                <div class="section-title">Time Slices (HH:MM:SS)</div>
                <div class="time-slices" id="slices"></div>
                <button class="btn btn-secondary" onclick="addSlice()">+ Add Slice</button>
            </div>
            <button class="btn btn-primary" onclick="process()">üöÄ Generate Plots</button>
            <div id="status"></div>
        </div>
        <div class="main-content">
            <div class="results-header">Results</div>
            <div class="plots-scroll-container" id="plots">
                <div class="empty-state">No plots generated yet. Configure settings and click "Generate Plots".</div>
            </div>
        </div>
    </div>
    <script>
        let files = [], plots = [], charts = [], iperfData = {}, pingData = {}, mode = "iperf", colors = ['#2c5282', '#38a169', '#d69e2e', '#c53030', '#805ad5', '#319795', '#dd6b20', '#e53e3e'];
        const els = {mode: 'mode', ip: 'ip', mac: 'mac', win: 'win', winVal: 'winVal', winLabel: 'winLabel', drop: 'drop', files: 'files', fileList: 'fileList', sliceDrop: 'sliceDrop', sliceFiles: 'sliceFiles', slices: 'slices', plots: 'plots', status: 'status', ipSec: 'ipSec', macSec: 'macSec', logSec: 'logSec', sliceSec: 'sliceSec'};
        Object.keys(els).forEach(k => els[k] = document.getElementById(els[k]));

        const labels = {iperf: 'Smoothing Window', ping: 'Latency Smoothing', snr: 'SNR Smoothing', all: 'All Modes'};
        els.mode.onchange = e => {
            mode = e.target.value;
            els.winLabel.innerText = labels[mode];
            els.ipSec.style.display = mode === 'snr' ? 'none' : '';
            els.macSec.style.display = ['snr', 'all'].includes(mode) ? '' : 'none';
            renderChecks();
        };

        els.win.oninput = e => els.winVal.textContent = e.target.value;

        const setupDrop = (zone, input, handler) => {
            zone.onclick = () => input.click();
            zone.ondragover = e => { e.preventDefault(); zone.classList.add('dragover'); };
            zone.ondragleave = () => zone.classList.remove('dragover');
            zone.ondrop = e => { e.preventDefault(); zone.classList.remove('dragover'); handler(e.dataTransfer.files); };
            input.onchange = e => handler(e.target.files);
        };

        setupDrop(els.drop, els.files, fileList => {
            for (let f of fileList) if (f.name.match(/\.(txt|log)$/)) files.push(f);
            updateFiles();
        });

        setupDrop(els.sliceDrop, els.sliceFiles, async fileList => {
            for (let f of fileList) {
                if (!f.name.match(/\.(txt|log)$/)) continue;
                const txt = await f.text();
                if (txt.match(/[A-Za-z]{3}\s+[A-Za-z]{3}\s+\d+\s+(\d{2}:\d{2}:\d{2})\s+\d{4}.*?\d+\.\d+-\d+\.\d+\s+sec/)) {
                    extractSlice(txt, f.name, false);
                    iperfData[f.name] = txt;
                } else if (txt.match(/(\d{4}-\d{2}-\d{2})\s+(\d{2}:\d{2}:\d{2})/)) {
                    extractSlice(txt, f.name, true);
                    pingData[f.name] = txt;
                } else showMsg('Could not parse: ' + f.name, 'error');
            }
        });

        const updateFiles = () => {
            els.fileList.innerHTML = '';
            files.forEach((f, i) => {
                const div = document.createElement('div');
                div.className = 'file-item';
                div.innerHTML = `<span>${f.name}</span><button onclick="files.splice(${i},1);updateFiles()">√ó</button>`;
                els.fileList.appendChild(div);
            });
        };

        const extractSlice = (txt, name, isPing) => {
            let first, last;
            const re = isPing ? /(\d{4}-\d{2}-\d{2})\s+(\d{2}:\d{2}:\d{2})/ : /[A-Za-z]{3}\s+[A-Za-z]{3}\s+\d+\s+(\d{2}:\d{2}:\d{2})\s+\d{4}.*?\d+\.\d+-\d+\.\d+\s+sec/;
            for (let l of txt.split('\n')) {
                const m = l.match(re);
                if (m) {
                    const t = isPing ? m[2] : m[1];
                    if (!first) first = t;
                    last = t;
                }
            }
            if (first && last) {
                addSlice(first, last, name);
                showMsg(`Added: ${first} to ${last}`, 'success');
            } else showMsg('No valid range in: ' + name, 'error');
        };

        const renderChecks = () => {
            document.querySelectorAll('.time-slice').forEach(s => {
                let c = s.querySelector('.checklist');
                if (mode === "all") {
                    if (!c) {
                        c = document.createElement('span');
                        c.className = 'checklist';
                        c.innerHTML = `<label><input type="checkbox" class="p" checked>Presence</label><label><input type="checkbox" class="t">Throughput</label><label><input type="checkbox" class="l">Latency</label><label><input type="checkbox" class="s">SNR</label>`;
                        s.insertBefore(c, s.lastChild);
                    }
                } else if (c) c.remove();
            });
        };

        const addSlice = (s = '00:00:00', e = '00:00:00', src = null) => {
            const div = document.createElement('div');
            div.className = src ? 'time-slice from-file' : 'time-slice';
            div.innerHTML = `${src ? `<div class="slice-label">üìÑ ${src}</div>` : ''}<input type="text" value="${s}" placeholder="HH:MM:SS"><span>to</span><input type="text" value="${e}" placeholder="HH:MM:SS"><button onclick="this.parentElement.remove()">√ó</button>`;
            els.slices.appendChild(div);
            renderChecks();
        };

        const showMsg = (msg, type = 'info') => {
            els.status.className = `status ${type}`;
            els.status.textContent = msg;
        };

        const movAvg = (data, w) => {
            if (w <= 1) return data;
            return data.map((d, i) => {
                const s = Math.max(0, i - Math.floor(w / 2));
                const e = Math.min(data.length, i + Math.ceil(w / 2));
                return { ...d, y: data.slice(s, e).reduce((sum, v) => sum + v.y, 0) / (e - s) };
            });
        };

        const parseLog = (txt, target, macMode = false) => {
            const secs = txt.split('/////'), data = [];
            let curTime, curStr;
            for (let s of secs) {
                const m = s.match(/LocalBeginTime:\s*(\d+)\s*\(([^)]+)\)/);
                if (m) {
                    curStr = m[2];
                    curTime = new Date(curStr.split('.')[0]);
                }
                if (curTime) {
                    if (macMode && s.includes(target)) {
                        let ack = null, rx = null, bssid = null;
                        for (let l of s.split('\n')) {
                            if (l.includes(target)) {
                                const p = l.trim().split(/\s+/);
                                if (p.length >= 17) {
                                    bssid = p[2];
                                    ack = parseInt(p[15]);
                                    rx = parseInt(p[16]);
                                }
                                break;
                            }
                        }
                        data.push({ time: curTime, present: 1, timeStr: curStr, lastAckSNR: ack, lastRxSNR: rx, bssid });
                    } else if (!macMode && s.includes(target)) {
                        data.push({ time: curTime, present: 1, timeStr: curStr });
                    } else if ((macMode && (s.includes('Client Table') || s.includes('Number of Clients'))) || (!macMode && s.includes('Number of Clients'))) {
                        data.push({ time: curTime, present: 0, timeStr: curStr, ...(macMode && { lastAckSNR: null, lastRxSNR: null, bssid: null }) });
                    }
                }
            }
            return data;
        };

        const parseIperf = txt => {
            const data = [];
            for (let l of txt.split('\n')) {
                const m = l.match(/[A-Za-z]{3}\s+[A-Za-z]{3}\s+\d+\s+(\d{2}:\d{2}:\d{2})\s+\d{4}.*?\d+\.\d+-\d+\.\d+\s+sec\s+[\d.]+\s+[A-Za-z]+\s+([\d.]+)\s+Mbits/);
                if (m) {
                    const [h, min, s] = m[1].split(':').map(Number);
                    data.push({ time: new Date(2000, 0, 1, h, min, s), timeStr: m[1], mbps: parseFloat(m[2]), originalTime: m[1] });
                }
            }
            return data;
        };

        const parsePing = txt => {
            const data = [];
            for (let l of txt.split('\n')) {
                const m = l.match(/(\d{4}-\d{2}-\d{2})\s+(\d{2}:\d{2}:\d{2}).*?time=([\d.]+)\s*ms/);
                if (m) {
                    const [y, mo, d] = m[1].split('-').map(Number);
                    const [h, min, s] = m[2].split(':').map(Number);
                    data.push({ time: new Date(y, mo - 1, d, h, min, s), timeStr: m[2], latency: parseFloat(m[3]), originalTime: m[2] });
                }
            }
            return data;
        };

        const toSec = t => {
            const [h, m, s] = t.split(':').map(Number);
            return h * 3600 + m * 60 + s;
        };

        async function process() {
            const w = parseInt(els.win.value);
            plots = [];
            const slices = Array.from(document.querySelectorAll('.time-slice')).map(s => {
                const ins = s.querySelectorAll('input[type="text"]');
                const c = s.querySelector('.checklist');
                return {
                    start: ins[0].value.trim(),
                    end: ins[1].value.trim(),
                    checks: mode === "all" && c ? {
                        p: c.querySelector('.p').checked,
                        t: c.querySelector('.t').checked,
                        l: c.querySelector('.l').checked,
                        s: c.querySelector('.s').checked
                    } : { p: true, t: false, l: false, s: false }
                };
            });

            if (!slices.length) return showMsg('Add at least one time slice', 'error');
            if ((mode !== 'snr' && !els.ip.value.trim()) || (['snr', 'all'].includes(mode) && !els.mac.value.trim() && mode === 'snr')) 
                return showMsg('Enter target address', 'error');
            if (!files.length) return showMsg('Add log files', 'error');

            showMsg('Processing...', 'info');

            const logData = {}, logDataMAC = {};
            for (let f of files) {
                const txt = await f.text();
                if (mode !== 'snr') logData[f.name] = parseLog(txt, els.ip.value.trim(), false);
                if (['snr', 'all'].includes(mode) && els.mac.value.trim()) logDataMAC[f.name] = parseLog(txt, els.mac.value.trim().toLowerCase(), true);
            }

            const iperfParsed = {}, pingParsed = {};
            for (let k in iperfData) iperfParsed[k] = parseIperf(iperfData[k]);
            for (let k in pingData) pingParsed[k] = parsePing(pingData[k]);

            let apNames = {}, apCtr = 1;

            slices.forEach((slice, idx) => {
                const st = toSec(slice.start), et = toSec(slice.end);
                const ds = [], filter = d => {
                    const t = d.time.getHours() * 3600 + d.time.getMinutes() * 60 + d.time.getSeconds();
                    return t >= st && t <= et;
                };

                if (mode === 'iperf' || (mode === 'all' && slice.checks.p)) {
                    Object.keys(logData).forEach((fn, i) => {
                        const filt = logData[fn].filter(filter);
                        if (filt.length) {
                            if (!apNames[fn]) apNames[fn] = `AP${apCtr++}`;
                            ds.push({
                                label: apNames[fn],
                                data: movAvg(filt.map(d => ({ x: toSec(d.time.toTimeString().split(' ')[0]) - st, y: d.present, originalTime: d.timeStr })), w),
                                borderColor: colors[i % colors.length],
                                backgroundColor: colors[i % colors.length] + '40',
                                tension: 0.4,
                                pointRadius: 0,
                                borderWidth: 2.5,
                                yAxisID: 'y'
                            });
                        }
                    });
                }

                if (mode === 'iperf' || (mode === 'all' && slice.checks.t)) {
                    Object.keys(iperfParsed).forEach(fn => {
                        const filt = iperfParsed[fn].filter(filter);
                        if (filt.length) {
                            ds.push({
                                label: `Throughput (${fn})`,
                                data: movAvg(filt.map(d => ({ x: toSec(d.time.toTimeString().split(' ')[0]) - st, y: d.mbps, originalTime: d.timeStr })), w),
                                borderColor: '#e63946',
                                backgroundColor: '#e6394620',
                                tension: 0.4,
                                pointRadius: 0,
                                borderWidth: 2,
                                yAxisID: 'y1'
                            });
                        }
                    });
                }

                if (mode === 'ping' || (mode === 'all' && slice.checks.l)) {
                    Object.keys(pingParsed).forEach(fn => {
                        const filt = pingParsed[fn].filter(filter);
                        if (filt.length) {
                            ds.push({
                                label: `Latency (${fn})`,
                                data: movAvg(filt.map(d => ({ x: toSec(d.time.toTimeString().split(' ')[0]) - st, y: d.latency, originalTime: d.timeStr })), w),
                                borderColor: '#e63946',
                                backgroundColor: '#e6394620',
                                tension: 0.4,
                                pointRadius: 0,
                                borderWidth: 2,
                                yAxisID: mode === 'all' ? 'y2' : 'y1'
                            });
                        }
                    });
                }

                if (mode === 'snr' || (mode === 'all' && slice.checks.s)) {
                    Object.keys(logDataMAC).forEach((fn, i) => {
                        const filt = logDataMAC[fn].filter(filter);
                        if (filt.length) {
                            if (!apNames[fn]) apNames[fn] = `AP${apCtr++}`;
                            ds.push({
                                label: `${apNames[fn]} - Presence`,
                                data: filt.map(d => ({ x: d.time.toTimeString().split(' ')[0], y: d.present, bssid: d.bssid, lastAckSNR: d.lastAckSNR, lastRxSNR: d.lastRxSNR, originalTime: d.timeStr })),
                                borderColor: colors[i % colors.length],
                                backgroundColor: colors[i % colors.length] + '40',
                                stepped: 'after',
                                pointRadius: 0,
                                borderWidth: 2.5,
                                yAxisID: 'y'
                            });
                            const ack = filt.filter(d => d.lastAckSNR !== null && d.present).map(d => ({ x: d.time.toTimeString().split(' ')[0], y: d.lastAckSNR, bssid: d.bssid, originalTime: d.timeStr }));
                            if (ack.length) ds.push({ label: `${apNames[fn]} - ACK SNR`, data: ack, borderColor: colors[i % colors.length], backgroundColor: colors[i % colors.length] + '20', pointRadius: 0, borderWidth: 2.5, yAxisID: mode === 'all' ? 'y3' : 'y1', tension: 0.4 });
                            const rx = filt.filter(d => d.lastRxSNR !== null && d.present).map(d => ({ x: d.time.toTimeString().split(' ')[0], y: d.lastRxSNR, bssid: d.bssid, originalTime: d.timeStr }));
                            if (rx.length) ds.push({ label: `${apNames[fn]} - Rx SNR`, data: rx, borderColor: colors[i % colors.length], backgroundColor: colors[i % colors.length] + '60', pointRadius: 0, borderWidth: 2.5, borderDash: [5, 5], yAxisID: mode === 'all' ? 'y3' : 'y1', tension: 0.4 });
                        }
                    });
                }

                if (ds.length) plots.push({ title: `Slice ${idx + 1}: ${slice.start} to ${slice.end}`, datasets: ds, index: idx, mode });
            });

            if (plots.length) {
                display();
                showMsg(`Generated ${plots.length} plot(s)`, 'success');
            } else showMsg('No data in time slices', 'error');
        }

        function display() {
            els.plots.innerHTML = '';
            charts.forEach(c => c.destroy());
            charts = [];
            plots.forEach((p, i) => {
                const div = document.createElement('div');
                div.className = 'plot-item';
                div.innerHTML = `<div class="plot-header"><div class="plot-title">${p.title}</div><div class="btn-group"><button class="copy-btn" onclick="copyPlot(${i})">üìã Copy</button><button class="export-btn" onclick="exportPlot(${i})">üíæ Export</button></div></div><div class="plot-canvas-wrapper"><canvas id="c${i}"></canvas></div>`;
                els.plots.appendChild(div);

                const scales = {
                    y: { type: 'linear', position: 'left', min: -0.1, max: 1.5, ticks: { stepSize: 1, callback: v => v === 0 ? 'Absent' : v === 1 ? 'Present' : '' }, title: { display: true, text: 'Connection Status', font: { weight: 'bold' } } }
                };
                if (p.mode === 'iperf') scales.y1 = { type: 'linear', position: 'right', title: { display: true, text: 'Throughput (Mbps)', font: { weight: 'bold' } }, grid: { drawOnChartArea: false } };
                if (p.mode === 'ping') scales.y1 = { type: 'linear', position: 'right', title: { display: true, text: 'Latency (ms)', font: { weight: 'bold' } }, grid: { drawOnChartArea: false } };
                if (p.mode === 'snr') {
                    scales.y.title.text = 'Presence';
                    scales.y1 = { type: 'linear', position: 'right', min: 0, title: { display: true
