<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WiFi Performance Analyzer (RX SNR only)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: Arial, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; padding: 20px; }
        .container { max-width: 1400px; margin: 0 auto; background: white; border-radius: 15px; padding: 30px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); }
        h1 { color: #667eea; text-align: center; margin-bottom: 30px; }
        .upload { background: #f8f9fa; padding: 25px; border-radius: 10px; margin-bottom: 30px; }
        label { display: block; font-weight: 600; margin: 15px 0 8px; color: #333; }
        input[type="text"], input[type="file"], textarea, select { width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 14px; margin-bottom: 10px; }
        textarea { min-height: 150px; font-family: monospace; resize: vertical; }
        .options { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 15px 0; }
        button { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; padding: 15px 40px; font-size: 16px; font-weight: 600; border-radius: 8px; cursor: pointer; transition: all .18s ease; }
        button:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4); }
        .chart-wrapper { background: #f8f9fa; padding: 20px; border-radius: 10px; margin: 20px 0; }
        .chart-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-wrap: wrap; gap: 10px; }
        .chart-title { font-size: 1.2em; font-weight: 600; color: #333; }
        .controls { display: flex; gap: 15px; align-items: center; }
        .slider { display: flex; align-items: center; gap: 10px; background: white; padding: 8px 15px; border-radius: 8px; }
        .slider input { width: 150px; }
        .slider span { font-weight: 700; color: #667eea; min-width: 30px; text-align: center; }
        .copy-btn { background: #43e97b; padding: 8px 15px; font-size: 14px; margin: 0; border-radius: 6px; color: #093; border: none; cursor: pointer; }
        .status { padding: 12px; border-radius: 8px; margin: 10px 0; text-align: center; display: none; }
        .status.show { display: block; }
        .status.error { background: #f8d7da; color: #721c24; }
        .status.success { background: #d4edda; color: #155724; }
        .debug-table { background: white; border-radius: 10px; padding: 20px; margin: 20px 0; }
        .debug-table h3 { color: #667eea; margin-bottom: 15px; }
        table { width: 100%; border-collapse: collapse; }
        table th, table td { padding: 10px; text-align: left; border-bottom: 1px solid #e0e0e0; }
        table th { background: #667eea; color: white; font-weight: 600; }
        table tr:hover { background: #f8f9fa; }
        .summary { margin-top: 12px; font-size: 14px; color: #333; }
        .legend { display:flex; gap:10px; align-items:center; margin-left:10px; }
        .legend span { display:inline-flex; width:16px; height:12px; border-radius:3px; margin-right:6px; }
        pre.segments { background: #fff; padding: 10px; border-radius: 8px; max-height: 220px; overflow: auto; font-size: 13px; }
        .stats-output { background: #fff; padding: 12px; border-radius: 8px; margin-top: 12px; }
        .stats-output pre { white-space: pre-wrap; font-size: 13px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üì° WiFi Performance Analyzer (RX SNR only)</h1>
        
        <div class="upload">
            <label>MAC Address:</label>
            <input type="text" id="mac" placeholder="e.g., 4c:49:6c:d4:db:a9" value="4c:49:6c:d4:db:a9">
            
            <label>Aruba WiFi Log File:</label>
            <input type="file" id="logFile" accept=".txt,.log">
            
            <label>Or Paste Log:</label>
            <textarea id="logText" placeholder="Paste Aruba log content..."></textarea>
            
            <label>Throughput Test Files (iperf3):</label>
            <input type="file" id="throughputFiles" accept=".txt,.log" multiple>
            
            <label>Latency Test Files (ping):</label>
            <input type="file" id="latencyFiles" accept=".txt,.log" multiple>
            
            <button onclick="analyze()">Analyze & Plot</button>
            <div id="status" class="status"></div>
        </div>
        
        <div id="debugTable"></div>
        <div id="charts"></div>
    </div>

    <script>
        let chartInstances = [];

        // Plugin to draw colored background segments behind charts (used for latency)
        const segmentBackground = {
            id: 'segmentBackground',
            beforeDraw: (chart, args, options) => {
                if (!options || !options.enabled || !options.segments) return;
                const ctx = chart.ctx;
                const xScale = chart.scales.x;
                if (!xScale) return;
                const top = chart.chartArea.top;
                const bottom = chart.chartArea.bottom;
                const segments = options.segments;
                for (let i = 0; i < segments.length; i++) {
                    const color = segments[i];
                    if (!color) continue;
                    const left = xScale.getPixelForValue(i - 0.5);
                    const right = xScale.getPixelForValue(i + 0.5);
                    const drawLeft = Math.max(left, chart.chartArea.left);
                    const drawRight = Math.min(right, chart.chartArea.right);
                    if (drawRight <= drawLeft) continue;
                    ctx.save();
                    ctx.fillStyle = color;
                    ctx.fillRect(drawLeft, top, drawRight - drawLeft, bottom - top);
                    ctx.restore();
                }
            }
        };

        Chart.register(segmentBackground);

        document.getElementById('logFile').onchange = async (e) => {
            document.getElementById('logText').value = await e.target.files[0].text();
        };

        function status(msg, type) {
            let s = document.getElementById('status');
            s.textContent = msg;
            s.className = `status show ${type}`;
            setTimeout(() => s.style.display = 'none', 4000);
        }

        function smooth(data, w) {
            if (w <= 1) return data;
            return data.map((_, i) => {
                let start = Math.max(0, i - Math.floor(w/2));
                let end = Math.min(data.length, i + Math.ceil(w/2));
                let win = data.slice(start, end).filter(v => v != null);
                return win.length ? win.reduce((a,b) => a+b) / win.length : null;
            });
        }

        async function copyChart(chart) {
            chart.options.scales.x.grid.display = true;
            chart.options.scales.y.grid.display = true;
            chart.options.scales.y1.grid.display = true;
            chart.update();
            
            let bg = {
                id: 'bg',
                beforeDraw: (c) => {
                    let ctx = c.canvas.getContext('2d');
                    ctx.save();
                    ctx.globalCompositeOperation = 'destination-over';
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(0, 0, c.width, c.height);
                    ctx.restore();
                }
            };
            Chart.register(bg);
            chart.update();
            
            try {
                let blob = await new Promise(r => chart.canvas.toBlob(r));
                await navigator.clipboard.write([new ClipboardItem({'image/png': blob})]);
                status('Chart copied!', 'success');
            } catch (e) {
                status('Copy failed', 'error');
            }
            
            Chart.unregister(bg);
            chart.options.scales.x.grid.display = false;
            chart.options.scales.y.grid.display = false;
            chart.options.scales.y1.grid.display = false;
            chart.update();
        }

        function computeStats(values) {
            // values is array of numbers (no nulls)
            if (!values || !values.length) return null;
            let n = values.length;
            let sum = values.reduce((a,b) => a+b, 0);
            let mean = sum / n;
            let min = Math.min(...values);
            let max = Math.max(...values);
            // population std deviation
            let variance = values.map(v => (v - mean) ** 2).reduce((a,b) => a+b, 0) / n;
            let std = Math.sqrt(variance);
            // avg jitter: average absolute difference between consecutive valid samples
            let diffs = [];
            for (let i = 1; i < values.length; i++) diffs.push(Math.abs(values[i] - values[i-1]));
            let avgJitter = diffs.length ? diffs.reduce((a,b) => a+b, 0) / diffs.length : 0;
            return {min, max, mean, std, avgJitter, count: n};
        }

        async function analyze() {
            let mac = document.getElementById('mac').value.trim().toLowerCase();
            let logText = document.getElementById('logText').value.trim();
            let throughputFiles = document.getElementById('throughputFiles').files;
            let latencyFiles = document.getElementById('latencyFiles').files;
            
            if (!mac || !logText || !throughputFiles.length || !latencyFiles.length) {
                status('Provide MAC, log, throughput and latency files', 'error');
                return;
            }
            
            // Parse WiFi log - only RX SNR is collected
            let lines = logText.split('\n');
            let wifiData = [];
            let ts = null, noise = null;
            
            for (let line of lines) {
                let m = line.match(/LocalBeginTime:\s*\d+\s*\(([^)]+)\)/);
                if (m) ts = m[1];
                
                m = line.match(/Current Noise Floor\s+(\d+)/);
                if (m) noise = parseInt(m[1]);
                
                if (line.toLowerCase().includes(mac)) {
                    let parts = line.split(/\s+/);
                    let idx = parts.findIndex(p => p.toLowerCase() === mac);
                    if (idx >= 0 && parts.length > idx + 16) {
                        // original code had ack at idx+15 and rx at idx+16; we only use rx
                        let rx = parseInt(parts[idx + 16]);
                        if (!isNaN(rx) && ts) {
                            wifiData.push({
                                ts: new Date(ts).getTime() / 1000,
                                rx: rx,
                                noise: noise
                            });
                        }
                    }
                }
            }
            
            if (!wifiData.length) {
                status('No WiFi data found for MAC', 'error');
                return;
            }
            
            // Reset UI areas
            document.getElementById('charts').innerHTML = '';
            document.getElementById('debugTable').innerHTML = '';
            chartInstances = [];
            
            // Process throughput files - aggregate all runs, STRICT 100s limit
            let allThroughputRuns = [];
            let debugInfo = [];
            
            for (let file of throughputFiles) {
                let text = await file.text();
                let testLines = text.split('\n');
                let perf = [], timestamps = [], start = null, end = null;
                
                for (let l of testLines) {
                    let m = l.match(/^(\w{3}\s+\w{3}\s+\d+\s+\d{2}:\d{2}:\d{2}\s+\d{4})/);
                    if (m) {
                        let t = new Date(m[1]).getTime() / 1000;
                        if (!start) start = t;
                        
                        let elapsed = t - start;
                        
                        // STRICT: Only include data points within first 100 seconds
                        if (elapsed > 100) {
                            console.log(`Throughput ${file.name}: Stopping at ${elapsed.toFixed(2)}s (exceeded 100s limit)`);
                            break;
                        }
                        
                        let th = l.match(/(\d+\.?\d*)\s+Mbits\/sec/);
                        if (th) {
                            perf.push(parseFloat(th[1]));
                            timestamps.push(t);
                            end = t;
                        }
                    }
                }
                
                if (!start || !perf.length) continue;
                
                let duration = end - start;
                console.log(`Throughput ${file.name}: ${perf.length} points, ${duration.toFixed(2)}s duration`);
                
                let filtered = wifiData.filter(d => d.ts >= start && d.ts <= end);
                if (!filtered.length) continue;
                
                let rx = filtered.map(d => d.rx);
                
                allThroughputRuns.push({rx, perf, start, end, fileName: file.name, duration});
            }
            
            if (!allThroughputRuns.length) {
                status('No valid throughput data found', 'error');
                return;
            }
            
            // Process latency files - align with throughput time ranges
            let allLatencyRuns = [];
            
            for (let i = 0; i < latencyFiles.length && i < allThroughputRuns.length; i++) {
                let file = latencyFiles[i];
                let throughputRun = allThroughputRuns[i];
                let text = await file.text();
                let testLines = text.split('\n');
                let perf = [], timestamps = [], start = null, end = null;
                
                for (let l of testLines) {
                    // Accept common timestamp formats for ping logs
                    let m = l.match(/^(\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2})/) || l.match(/^(\w{3}\s+\w{3}\s+\d+\s+\d{2}:\d{2}:\d{2}\s+\d{4})/);
                    if (m) {
                        let t = new Date(m[1]).getTime() / 1000;
                        if (!start) start = t;
                        
                        let elapsed = t - start;
                        
                        // STRICT: Only include data points within first 100 seconds
                        if (elapsed > 100) {
                            console.log(`Latency ${file.name}: Stopping at ${elapsed.toFixed(2)}s (exceeded 100s limit)`);
                            break;
                        }
                        
                        let lat = l.match(/time=(\d+\.?\d*)\s*ms/);
                        if (lat) {
                            let val = parseFloat(lat[1]);
                            perf.push(isNaN(val) ? null : val);
                            timestamps.push(t);
                            end = t;
                        }
                    }
                }
                
                if (!start || !perf.length) continue;
                
                let duration = end - start;
                console.log(`Latency ${file.name}: ${perf.length} points, ${duration.toFixed(2)}s duration`);
                
                // Handle spikes > 500ms: replace them with previous value if exists, else next valid value.
                // This "marks it to be the previous or the next latency" to remove extreme outliers.
                for (let idx = 0; idx < perf.length; idx++) {
                    if (perf[idx] != null && perf[idx] > 500) {
                        // try previous
                        if (idx > 0 && perf[idx-1] != null) {
                            perf[idx] = perf[idx-1];
                        } else {
                            // find next non-null
                            let found = null;
                            for (let j = idx+1; j < perf.length; j++) {
                                if (perf[j] != null && perf[j] <= 500) { found = perf[j]; break; }
                            }
                            perf[idx] = found !== null ? found : null;
                        }
                    }
                }
                
                // Trim/pad latency to match throughput length
                let targetLen = throughputRun.perf.length;
                let originalLen = perf.length;
                
                if (perf.length > targetLen) {
                    perf = perf.slice(0, targetLen);
                    console.log(`Latency ${file.name}: Trimmed from ${originalLen} to ${targetLen} points`);
                } else if (perf.length < targetLen) {
                    while(perf.length < targetLen) perf.push(null);
                    console.log(`Latency ${file.name}: Padded from ${originalLen} to ${targetLen} points`);
                }
                
                debugInfo.push({
                    throughputFile: throughputRun.fileName,
                    latencyFile: file.name,
                    throughputPoints: throughputRun.perf.length,
                    latencyPoints: originalLen,
                    throughputDuration: throughputRun.duration.toFixed(2),
                    latencyDuration: duration.toFixed(2),
                    alignedLength: targetLen
                });
                
                allLatencyRuns.push({perf, fileName: file.name});
            }
            
            // Create debug table
            if (debugInfo.length > 0) {
                let tableHTML = `
                    <div class="debug-table">
                        <h3>üîç Debug: File Alignment Information</h3>
                        <table>
                            <thead>
                                <tr>
                                    <th>Run #</th>
                                    <th>Throughput File</th>
                                    <th>Latency File</th>
                                    <th>Throughput Points</th>
                                    <th>Latency Points</th>
                                    <th>Throughput Duration (s)</th>
                                    <th>Latency Duration (s)</th>
                                    <th>Final Aligned Length</th>
                                </tr>
                            </thead>
                            <tbody>
                `;
                
                debugInfo.forEach((info, idx) => {
                    tableHTML += `
                        <tr>
                            <td>${idx + 1}</td>
                            <td>${info.throughputFile}</td>
                            <td>${info.latencyFile}</td>
                            <td>${info.throughputPoints}</td>
                            <td>${info.latencyPoints}</td>
                            <td>${info.throughputDuration}</td>
                            <td>${info.latencyDuration}</td>
                            <td>${info.alignedLength}</td>
                        </tr>
                    `;
                });
                
                tableHTML += `
                            </tbody>
                        </table>
                    </div>
                `;
                
                document.getElementById('debugTable').innerHTML = tableHTML;
            }
            
            // Find max length and pad arrays for throughput (use RX & perf lengths)
            let maxLen = Math.max(...allThroughputRuns.map(r => Math.max(r.rx.length, r.perf.length)));
            
            // FORCE maxLen to represent max 100 seconds
            // Calculate samples per second and cap at 100s worth
            let avgSamplesPerRun = allThroughputRuns.map(r => r.perf.length / (r.duration || 1));
            let avgSampleRate = avgSamplesPerRun.reduce((a,b) => a+b) / avgSamplesPerRun.length;
            let max100sLength = Math.ceil(avgSampleRate * 100);
            
            if (maxLen > max100sLength) {
                console.log(`Capping maxLen from ${maxLen} to ${max100sLength} (100s limit)`);
                maxLen = max100sLength;
            }
            
            allThroughputRuns.forEach(r => {
                // Trim if exceeds maxLen
                if (r.rx.length > maxLen) r.rx = r.rx.slice(0, maxLen);
                if (r.perf.length > maxLen) r.perf = r.perf.slice(0, maxLen);
                
                // Pad to maxLen
                while(r.rx.length < maxLen) r.rx.push(null);
                while(r.perf.length < maxLen) r.perf.push(null);
            });
            
            // Pad latency arrays to match throughput maxLen
            allLatencyRuns.forEach(r => {
                if (r.perf.length > maxLen) r.perf = r.perf.slice(0, maxLen);
                while(r.perf.length < maxLen) r.perf.push(null);
            });
            
            // Calculate mean and std for RX SNR and throughput
            let labels = Array.from({length: maxLen}, (_, i) => i);
            let rxMean = [], rxStd = [], throughputMean = [], throughputStd = [];
            
            for (let i = 0; i < maxLen; i++) {
                let rxVals = allThroughputRuns.map(r => r.rx[i]).filter(v => v != null);
                let throughputVals = allThroughputRuns.map(r => r.perf[i]).filter(v => v != null);
                
                rxMean[i] = rxVals.length ? rxVals.reduce((a,b) => a+b) / rxVals.length : null;
                throughputMean[i] = throughputVals.length ? throughputVals.reduce((a,b) => a+b) / throughputVals.length : null;
                
                rxStd[i] = rxVals.length > 1 ? Math.sqrt(rxVals.map(v => (v - rxMean[i])**2).reduce((a,b) => a+b) / rxVals.length) : 0;
                throughputStd[i] = throughputVals.length > 1 ? Math.sqrt(throughputVals.map(v => (v - throughputMean[i])**2).reduce((a,b) => a+b) / throughputVals.length) : 0;
            }
            
            // Calculate mean and std for latency
            let latencyMean = [], latencyStd = [];
            
            for (let i = 0; i < maxLen; i++) {
                let latencyVals = allLatencyRuns.map(r => r.perf[i]).filter(v => v != null);
                
                latencyMean[i] = latencyVals.length ? latencyVals.reduce((a,b) => a+b) / latencyVals.length : null;
                latencyStd[i] = latencyVals.length > 1 ? Math.sqrt(latencyVals.map(v => (v - latencyMean[i])**2).reduce((a,b) => a+b) / latencyVals.length) : 0;
            }
            
            // Create throughput chart (RX SNR + throughput)
            createChart(`Throughput (${allThroughputRuns.length} runs)`, labels, rxMean, rxStd, throughputMean, throughputStd, 'iperf3', null);
            // Create latency chart, pass per-run latency arrays so we can compute colored segments and stats
            const latencyPerRuns = allLatencyRuns.map(r => r.perf);
            const latencyFilesNames = allLatencyRuns.map(r => r.fileName);
            createChart(`Latency (${allLatencyRuns.length} runs)`, labels, rxMean, rxStd, latencyMean, latencyStd, 'ping', latencyPerRuns, latencyFilesNames);
            
            status('Analysis complete!', 'success');
        }

        function createChart(name, labels, rxMean, rxStd, perfMean, perfStd, type, perRunData, perRunNames) {
            let wrapper = document.createElement('div');
            wrapper.className = 'chart-wrapper';
            
            let header = document.createElement('div');
            header.className = 'chart-header';
            header.innerHTML = `<div class="chart-title">${name}</div>`;
            
            let controls = document.createElement('div');
            controls.className = 'controls';
            
            let slider = document.createElement('div');
            slider.className = 'slider';
            slider.innerHTML = '<label>Smooth:</label><input type="range" min="1" max="50" value="1"><span>1</span>';
            let range = slider.querySelector('input');
            let span = slider.querySelector('span');
            controls.appendChild(slider);
            
            let legend = document.createElement('div');
            legend.className = 'legend';
            legend.innerHTML = `
                <div style="display:flex;align-items:center;gap:8px;">
                    <span style="background:#4caf50;"></span> Green &nbsp;
                    <span style="background:#ffc107;"></span> Yellow &nbsp;
                    <span style="background:#ff8a65;"></span> Orange &nbsp;
                    <span style="background:#bdbdbd;"></span> No data
                </div>
            `;
            controls.appendChild(legend);
            
            let copy = document.createElement('button');
            copy.className = 'copy-btn';
            copy.textContent = 'üìã Copy';
            controls.appendChild(copy);
            
            header.appendChild(controls);
            wrapper.appendChild(header);
            
            let canvas = document.createElement('canvas');
            wrapper.appendChild(canvas);

            // summary container for showing colored segment ranges (text)
            let summaryDiv = document.createElement('div');
            summaryDiv.className = 'summary';
            wrapper.appendChild(summaryDiv);

            // stats output container
            let statsDiv = document.createElement('div');
            statsDiv.className = 'stats-output';
            wrapper.appendChild(statsDiv);

            document.getElementById('charts').appendChild(wrapper);
            
            // Create std bands
            let rxUpper = rxMean.map((m, i) => (m != null && rxStd[i] != null) ? m + rxStd[i] : null);
            let rxLower = rxMean.map((m, i) => (m != null && rxStd[i] != null) ? m - rxStd[i] : null);
            let perfUpper = perfMean.map((m, i) => (m != null && perfStd[i] != null) ? m + perfStd[i] : null);
            let perfLower = perfMean.map((m, i) => (m != null && perfStd[i] != null) ? m - perfStd[i] : null);
            
            // Datasets: RX SNR band/mean/lower and performance band/mean/lower
            const datasets = [
                // RX +œÉ (we will fill to RX mean)
                { label: 'RX SNR +œÉ', data: rxUpper, borderColor: 'rgba(240,147,251,0.25)', backgroundColor: 'rgba(240,147,251,0.08)', fill: '-1', tension: 0.4, borderWidth: 1, pointRadius: 0, yAxisID: 'y' },
                { label: 'RX SNR Mean', data: rxMean, borderColor: '#f093fb', backgroundColor: 'rgba(240,147,251,0.12)', tension: 0.4, borderWidth: 3, pointRadius: 0, yAxisID: 'y', fill: false },
                { label: 'RX SNR -œÉ', data: rxLower, borderColor: 'rgba(240,147,251,0.25)', backgroundColor: 'rgba(240,147,251,0.08)', fill: false, tension: 0.4, borderWidth: 1, pointRadius: 0, yAxisID: 'y' },

                // Performance +œÉ
                { label: (type === 'iperf3' ? 'Throughput' : 'Latency') + ' +œÉ', data: perfUpper, borderColor: 'rgba(255,107,107,0.25)', backgroundColor: 'rgba(255,107,107,0.08)', fill: '-1', tension: 0.4, borderWidth: 1, pointRadius: 0, yAxisID: 'y1' },
                { label: (type === 'iperf3' ? 'Throughput' : 'Latency') + ' Mean', data: perfMean, borderColor: '#ff6b6b', backgroundColor: 'rgba(255,107,107,0.12)', tension: 0.4, borderWidth: 3, pointRadius: 0, yAxisID: 'y1', fill: false },
                { label: (type === 'iperf3' ? 'Throughput' : 'Latency') + ' -œÉ', data: perfLower, borderColor: 'rgba(255,107,107,0.25)', backgroundColor: 'rgba(255,107,107,0.08)', fill: false, tension: 0.4, borderWidth: 1, pointRadius: 0, yAxisID: 'y1' },
            ];
            
            // Build status segments for latency (perRunData)
            let segmentColors = null;
            let segmentCategories = null;
            let longestBlocks = null;
            let statsReportText = '';
            if (type === 'ping' && Array.isArray(perRunData)) {
                const maxLen = labels.length;
                segmentColors = new Array(maxLen);
                segmentCategories = new Array(maxLen);
                // thresholds
                const T_GREEN = 50;   // under 40ms -> green
                const T_YELLOW = 75;  // 40-75 -> yellow, >75 -> orange
                for (let i = 0; i < maxLen; i++) {
                    let vals = perRunData.map(r => r[i]).filter(v => v != null);
                    if (!vals.length) {
                        segmentCategories[i] = 'NO_DATA';
                        segmentColors[i] = 'rgba(189,189,189,0.06)';
                    } else if (vals.some(v => v > T_YELLOW)) {
                        segmentCategories[i] = 'ORANGE (>75ms in at least one run)';
                        segmentColors[i] = 'rgba(255,138,101,0.12)'; // orange
                    } else if (vals.some(v => v >= T_GREEN)) {
                        segmentCategories[i] = 'YELLOW (>=40ms in at least one run)';
                        segmentColors[i] = 'rgba(255,193,7,0.12)'; // yellow
                    } else {
                        segmentCategories[i] = 'GREEN (all runs <40ms)';
                        segmentColors[i] = 'rgba(76,175,80,0.08)'; // green
                    }
                }

                // Compute contiguous ranges for summary (group consecutive indices with same category)
                const ranges = [];
                let curCat = segmentCategories[0];
                let start = 0;
                for (let i = 1; i <= segmentCategories.length; i++) {
                    if (i === segmentCategories.length || segmentCategories[i] !== curCat) {
                        ranges.push({from: start, to: i - 1, category: curCat, len: i - start});
                        start = i;
                        curCat = segmentCategories[i];
                    }
                }

                // Find greatest contiguous block for GREEN, YELLOW, ORANGE (ignore NO_DATA)
                const wantedCats = {
                    'GREEN (all runs <40ms)': 'GREEN',
                    'YELLOW (>=40ms in at least one run)': 'YELLOW',
                    'ORANGE (>75ms in at least one run)': 'ORANGE'
                };
                longestBlocks = {GREEN: null, YELLOW: null, ORANGE: null};
                for (let catKey in wantedCats) {
                    let simple = wantedCats[catKey];
                    let filtered = ranges.filter(r => r.category === catKey);
                    if (filtered.length) {
                        // pick the longest
                        filtered.sort((a,b) => b.len - a.len);
                        let best = filtered[0];
                        longestBlocks[simple] = {from: best.from, to: best.to, len: best.len};
                    } else {
                        longestBlocks[wantedCats[catKey]] = null;
                    }
                }

                // Build summary text
                let summaryHtml = `<div style="margin-top:8px;"><strong>Latency segment summary (contiguous ranges):</strong></div>`;
                summaryHtml += `<pre class="segments">`;
                ranges.forEach(r => {
                    summaryHtml += `From ${r.from}s to ${r.to}s (${r.len}s): ${r.category}\n`;
                });
                summaryHtml += `</pre>`;
                summaryDiv.innerHTML = summaryHtml;

                // For each longest block, compute stats per file (perRunData)
                statsReportText += ''; // we'll add lines below
                const catsOrder = ['GREEN', 'YELLOW', 'ORANGE'];
                catsOrder.forEach(cat => {
                    let block = longestBlocks[cat];
                    if (!block) {
                        statsReportText += `OK for ${cat.toLowerCase()} area: No contiguous block found.\n\n`;
                        return;
                    }
                    statsReportText += `OK for ${cat.toLowerCase()} area (largest contiguous block: ${block.from}s to ${block.to}s, length ${block.len}s):\n`;
                    // for each file
                    for (let f = 0; f < perRunData.length; f++) {
                        let arr = perRunData[f].slice(block.from, block.to + 1).filter(v => v != null);
                        let stats = computeStats(arr);
                        let fileName = (perRunNames && perRunNames[f]) ? perRunNames[f] : `file ${f+1}`;
                        if (!stats) {
                            statsReportText += `  for ${fileName} it is: No data in this block\n`;
                        } else {
                            statsReportText += `  for ${fileName} it is: min=${stats.min.toFixed(3)}, max=${stats.max.toFixed(3)}, avg=${stats.mean.toFixed(3)}, avg_jitter=${stats.avgJitter.toFixed(3)}, std=${stats.std.toFixed(3)}\n`;
                        }
                    }
                    statsReportText += `\n`;
                });

                // Also provide a concise listing of the longest block per category
                let blocksSummary = `Largest contiguous blocks per category:\n`;
                ['GREEN','YELLOW','ORANGE'].forEach(k => {
                    let b = longestBlocks[k];
                    if (b) blocksSummary += `${k}: from ${b.from}s to ${b.to}s (len ${b.len}s)\n`;
                    else blocksSummary += `${k}: none\n`;
                });
                statsReportText = blocksSummary + '\n' + statsReportText;
                statsDiv.innerHTML = `<pre>${statsReportText}</pre>`;
            } else {
                summaryDiv.innerHTML = '';
                statsDiv.innerHTML = '';
            }
            
            const chart = new Chart(canvas, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    interaction: {mode: 'index', intersect: false},
                    plugins: {
                        legend: { display: true, position: 'top' },
                        segmentBackground: {
                            enabled: type === 'ping' && !!segmentColors,
                            segments: segmentColors
                        }
                    },
                    scales: {
                        x: {
                            title: {display: true, text: 'Time (s)', font: {weight: 'bold'}}, 
                            grid: {display: false},
                            min: 0,
                            max: Math.max(...labels, 100)
                        },
                        y: {title: {display: true, text: 'RX SNR (dB)', font: {weight: 'bold'}}, position: 'left', grid: {display: false}},
                        y1: {title: {display: true, text: type === 'iperf3' ? 'Throughput (Mbps)' : 'Latency (ms)', font: {weight: 'bold'}}, position: 'right', grid: {display: false}}
                    }
                }
            });
            
            chartInstances.push({chart: chart, rawRxMean: rxMean, rawRxStd: rxStd, rawPerfMean: perfMean, rawPerfStd: perfStd});
            let idx = chartInstances.length - 1;
            
            range.oninput = () => {
                span.textContent = range.value;
                let w = parseInt(range.value);
                let sRxMean = smooth(chartInstances[idx].rawRxMean, w);
                let sRxStd = smooth(chartInstances[idx].rawRxStd, w);
                let sPerfMean = smooth(chartInstances[idx].rawPerfMean, w);
                let sPerfStd = smooth(chartInstances[idx].rawPerfStd, w);
                
                chart.data.datasets[0].data = sRxMean.map((m, i) => m != null && sRxStd[i] != null ? m + sRxStd[i] : null);
                chart.data.datasets[1].data = sRxMean;
                chart.data.datasets[2].data = sRxMean.map((m, i) => m != null && sRxStd[i] != null ? m - sRxStd[i] : null);
                chart.data.datasets[3].data = sPerfMean.map((m, i) => m != null && sPerfStd[i] != null ? m + sPerfStd[i] : null);
                chart.data.datasets[4].data = sPerfMean;
                chart.data.datasets[5].data = sPerfMean.map((m, i) => m != null && sPerfStd[i] != null ? m - sPerfStd[i] : null);
                
                chart.update();
            };
            
            copy.onclick = () => copyChart(chart);
        }
    </script>
</body>
</html>
