<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WiFi Performance Analyzer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: Arial, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; padding: 20px; }
        .container { max-width: 1400px; margin: 0 auto; background: white; border-radius: 15px; padding: 30px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); }
        h1 { color: #667eea; text-align: center; margin-bottom: 30px; }
        .upload { background: #f8f9fa; padding: 25px; border-radius: 10px; margin-bottom: 30px; }
        label { display: block; font-weight: 600; margin: 15px 0 8px; color: #333; }
        input[type="text"], input[type="file"], textarea, select { width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 14px; margin-bottom: 10px; }
        textarea { min-height: 150px; font-family: monospace; resize: vertical; }
        .options { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 15px 0; }
        button { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; padding: 15px 40px; font-size: 16px; font-weight: 600; border-radius: 8px; cursor: pointer; transition: all .18s ease; }
        button:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4); }
        .chart-wrapper { background: #f8f9fa; padding: 20px; border-radius: 10px; margin: 20px 0; }
        .chart-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-wrap: wrap; gap: 10px; }
        .chart-title { font-size: 1.2em; font-weight: 600; color: #333; }
        .controls { display: flex; gap: 15px; align-items: center; }
        .slider { display: flex; align-items: center; gap: 10px; background: white; padding: 8px 15px; border-radius: 8px; }
        .slider input { width: 150px; }
        .slider span { font-weight: 700; color: #667eea; min-width: 30px; text-align: center; }
        .copy-btn { background: #43e97b; padding: 8px 15px; font-size: 14px; margin: 0; border-radius: 6px; color: #093; border: none; cursor: pointer; }
        .status { padding: 12px; border-radius: 8px; margin: 10px 0; text-align: center; display: none; }
        .status.show { display: block; }
        .status.error { background: #f8d7da; color: #721c24; }
        .status.success { background: #d4edda; color: #155724; }
        .debug-table { background: white; border-radius: 10px; padding: 20px; margin: 20px 0; }
        .debug-table h3 { color: #667eea; margin-bottom: 15px; }
        table { width: 100%; border-collapse: collapse; }
        table th, table td { padding: 10px; text-align: left; border-bottom: 1px solid #e0e0e0; }
        table th { background: #667eea; color: white; font-weight: 600; }
        table tr:hover { background: #f8f9fa; }
        .summary { margin-top: 12px; font-size: 14px; color: #333; }
        .legend { display:flex; gap:10px; align-items:center; margin-left:10px; }
        .legend span { display:inline-flex; width:16px; height:12px; border-radius:3px; margin-right:6px; }
        pre.segments { background: #fff; padding: 10px; border-radius: 8px; max-height: 220px; overflow: auto; font-size: 13px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üì° WiFi Performance Analyzer</h1>
        
        <div class="upload">
            <label>MAC Address:</label>
            <input type="text" id="mac" placeholder="e.g., 4c:49:6c:d4:db:a9" value="4c:49:6c:d4:db:a9">
            
            <label>Aruba WiFi Log File:</label>
            <input type="file" id="logFile" accept=".txt,.log">
            
            <label>Or Paste Log:</label>
            <textarea id="logText" placeholder="Paste Aruba log content..."></textarea>
            
            <label>Throughput Test Files (iperf3):</label>
            <input type="file" id="throughputFiles" accept=".txt,.log" multiple>
            
            <label>Latency Test Files (ping):</label>
            <input type="file" id="latencyFiles" accept=".txt,.log" multiple>
            
            <button onclick="analyze()">Analyze & Plot</button>
            <div id="status" class="status"></div>
        </div>
        
        <div id="debugTable"></div>
        <div id="charts"></div>
    </div>

    <script>
        let chartInstances = [];

        // Plugin to draw colored background segments behind charts (used for latency)
        const segmentBackground = {
            id: 'segmentBackground',
            beforeDraw: (chart, args, options) => {
                // options: { enabled: true, segments: [...colors], alpha: 0.08 }
                if (!options || !options.enabled || !options.segments) return;
                const ctx = chart.ctx;
                const xScale = chart.scales.x;
                if (!xScale) return;
                const top = chart.chartArea.top;
                const bottom = chart.chartArea.bottom;
                const segments = options.segments;
                for (let i = 0; i < segments.length; i++) {
                    const color = segments[i];
                    if (!color) continue;
                    // compute left & right pixel for each index (assuming labels are numeric indices)
                    const left = xScale.getPixelForValue(i - 0.5);
                    const right = xScale.getPixelForValue(i + 0.5);
                    // clip drawing area
                    const drawLeft = Math.max(left, chart.chartArea.left);
                    const drawRight = Math.min(right, chart.chartArea.right);
                    if (drawRight <= drawLeft) continue;
                    ctx.save();
                    ctx.fillStyle = color;
                    ctx.fillRect(drawLeft, top, drawRight - drawLeft, bottom - top);
                    ctx.restore();
                }
            }
        };

        Chart.register(segmentBackground);

        document.getElementById('logFile').onchange = async (e) => {
            document.getElementById('logText').value = await e.target.files[0].text();
        };

        function status(msg, type) {
            let s = document.getElementById('status');
            s.textContent = msg;
            s.className = `status show ${type}`;
            setTimeout(() => s.style.display = 'none', 3000);
        }

        function smooth(data, w) {
            if (w <= 1) return data;
            return data.map((_, i) => {
                let start = Math.max(0, i - Math.floor(w/2));
                let end = Math.min(data.length, i + Math.ceil(w/2));
                let win = data.slice(start, end).filter(v => v != null);
                return win.length ? win.reduce((a,b) => a+b) / win.length : null;
            });
        }

        async function copyChart(chart) {
            chart.options.scales.x.grid.display = true;
            chart.options.scales.y.grid.display = true;
            chart.options.scales.y1.grid.display = true;
            chart.update();
            
            let bg = {
                id: 'bg',
                beforeDraw: (c) => {
                    let ctx = c.canvas.getContext('2d');
                    ctx.save();
                    ctx.globalCompositeOperation = 'destination-over';
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(0, 0, c.width, c.height);
                    ctx.restore();
                }
            };
            Chart.register(bg);
            chart.update();
            
            try {
                let blob = await new Promise(r => chart.canvas.toBlob(r));
                await navigator.clipboard.write([new ClipboardItem({'image/png': blob})]);
                status('Chart copied!', 'success');
            } catch (e) {
                status('Copy failed', 'error');
            }
            
            Chart.unregister(bg);
            chart.options.scales.x.grid.display = false;
            chart.options.scales.y.grid.display = false;
            chart.options.scales.y1.grid.display = false;
            chart.update();
        }

        async function analyze() {
            let mac = document.getElementById('mac').value.trim().toLowerCase();
            let logText = document.getElementById('logText').value.trim();
            let throughputFiles = document.getElementById('throughputFiles').files;
            let latencyFiles = document.getElementById('latencyFiles').files;
            
            if (!mac || !logText || !throughputFiles.length || !latencyFiles.length) {
                status('Provide MAC, log, throughput and latency files', 'error');
                return;
            }
            
            // Parse WiFi log
            let lines = logText.split('\n');
            let wifiData = [];
            let ts = null, noise = null;
            
            for (let line of lines) {
                let m = line.match(/LocalBeginTime:\s*\d+\s*\(([^)]+)\)/);
                if (m) ts = m[1];
                
                m = line.match(/Current Noise Floor\s+(\d+)/);
                if (m) noise = parseInt(m[1]);
                
                if (line.toLowerCase().includes(mac)) {
                    let parts = line.split(/\s+/);
                    let idx = parts.findIndex(p => p.toLowerCase() === mac);
                    if (idx >= 0 && parts.length > idx + 16) {
                        let ack = parseInt(parts[idx + 15]);
                        let rx = parseInt(parts[idx + 16]);
                        if (!isNaN(ack) && !isNaN(rx) && ts) {
                            wifiData.push({
                                ts: new Date(ts).getTime() / 1000,
                                ack: ack,
                                rx: rx,
                                noise: noise
                            });
                        }
                    }
                }
            }
            
            if (!wifiData.length) {
                status('No WiFi data found for MAC', 'error');
                return;
            }
            
            // Process throughput files - aggregate all runs, STRICT 100s limit
            document.getElementById('charts').innerHTML = '';
            document.getElementById('debugTable').innerHTML = '';
            chartInstances = [];
            
            let allThroughputRuns = [];
            let debugInfo = [];
            
            for (let file of throughputFiles) {
                let text = await file.text();
                let testLines = text.split('\n');
                let perf = [], timestamps = [], start = null, end = null;
                
                for (let l of testLines) {
                    let m = l.match(/^(\w{3}\s+\w{3}\s+\d+\s+\d{2}:\d{2}:\d{2}\s+\d{4})/);
                    if (m) {
                        let t = new Date(m[1]).getTime() / 1000;
                        if (!start) start = t;
                        
                        let elapsed = t - start;
                        
                        // STRICT: Only include data points within first 100 seconds
                        if (elapsed > 100) {
                            console.log(`Throughput ${file.name}: Stopping at ${elapsed.toFixed(2)}s (exceeded 100s limit)`);
                            break;
                        }
                        
                        let th = l.match(/(\d+\.?\d*)\s+Mbits\/sec/);
                        if (th) {
                            perf.push(parseFloat(th[1]));
                            timestamps.push(t);
                            end = t;
                        }
                    }
                }
                
                if (!start || !perf.length) continue;
                
                let duration = end - start;
                console.log(`Throughput ${file.name}: ${perf.length} points, ${duration.toFixed(2)}s duration`);
                
                let filtered = wifiData.filter(d => d.ts >= start && d.ts <= end);
                if (!filtered.length) continue;
                
                let ack = filtered.map(d => d.ack);
                let rx = filtered.map(d => d.rx);
                
                allThroughputRuns.push({ack, rx, perf, start, end, fileName: file.name, duration});
            }
            
            if (!allThroughputRuns.length) {
                status('No valid throughput data found', 'error');
                return;
            }
            
            // Process latency files - align with throughput time ranges
            let allLatencyRuns = [];
            
            for (let i = 0; i < latencyFiles.length && i < allThroughputRuns.length; i++) {
                let file = latencyFiles[i];
                let throughputRun = allThroughputRuns[i];
                let text = await file.text();
                let testLines = text.split('\n');
                let perf = [], timestamps = [], start = null, end = null;
                
                for (let l of testLines) {
                    let m = l.match(/^(\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2})/);
                    if (m) {
                        let t = new Date(m[1]).getTime() / 1000;
                        if (!start) start = t;
                        
                        let elapsed = t - start;
                        
                        // STRICT: Only include data points within first 100 seconds
                        if (elapsed > 100) {
                            console.log(`Latency ${file.name}: Stopping at ${elapsed.toFixed(2)}s (exceeded 100s limit)`);
                            break;
                        }
                        
                        let lat = l.match(/time=(\d+\.?\d*)\s*ms/);
                        if (lat) {
                            perf.push(parseFloat(lat[1]));
                            timestamps.push(t);
                            end = t;
                        }
                    }
                }
                
                if (!start || !perf.length) continue;
                
                let duration = end - start;
                console.log(`Latency ${file.name}: ${perf.length} points, ${duration.toFixed(2)}s duration`);
                
                // Trim/pad latency to match throughput length
                let targetLen = throughputRun.perf.length;
                let originalLen = perf.length;
                
                if (perf.length > targetLen) {
                    perf = perf.slice(0, targetLen);
                    console.log(`Latency ${file.name}: Trimmed from ${originalLen} to ${targetLen} points`);
                } else if (perf.length < targetLen) {
                    while(perf.length < targetLen) perf.push(null);
                    console.log(`Latency ${file.name}: Padded from ${originalLen} to ${targetLen} points`);
                }
                
                debugInfo.push({
                    throughputFile: throughputRun.fileName,
                    latencyFile: file.name,
                    throughputPoints: throughputRun.perf.length,
                    latencyPoints: originalLen,
                    throughputDuration: throughputRun.duration.toFixed(2),
                    latencyDuration: duration.toFixed(2),
                    alignedLength: targetLen
                });
                
                allLatencyRuns.push({perf});
            }
            
            // Create debug table
            if (debugInfo.length > 0) {
                let tableHTML = `
                    <div class="debug-table">
                        <h3>üîç Debug: File Alignment Information</h3>
                        <table>
                            <thead>
                                <tr>
                                    <th>Run #</th>
                                    <th>Throughput File</th>
                                    <th>Latency File</th>
                                    <th>Throughput Points</th>
                                    <th>Latency Points</th>
                                    <th>Throughput Duration (s)</th>
                                    <th>Latency Duration (s)</th>
                                    <th>Final Aligned Length</th>
                                </tr>
                            </thead>
                            <tbody>
                `;
                
                debugInfo.forEach((info, idx) => {
                    tableHTML += `
                        <tr>
                            <td>${idx + 1}</td>
                            <td>${info.throughputFile}</td>
                            <td>${info.latencyFile}</td>
                            <td>${info.throughputPoints}</td>
                            <td>${info.latencyPoints}</td>
                            <td>${info.throughputDuration}</td>
                            <td>${info.latencyDuration}</td>
                            <td>${info.alignedLength}</td>
                        </tr>
                    `;
                });
                
                tableHTML += `
                            </tbody>
                        </table>
                    </div>
                `;
                
                document.getElementById('debugTable').innerHTML = tableHTML;
            }
            
            // Find max length and pad arrays for throughput
            let maxLen = Math.max(...allThroughputRuns.map(r => Math.max(r.ack.length, r.rx.length, r.perf.length)));
            
            // FORCE maxLen to represent max 100 seconds
            // Calculate samples per second and cap at 100s worth
            let avgSamplesPerRun = allThroughputRuns.map(r => r.perf.length / (r.duration || 1));
            let avgSampleRate = avgSamplesPerRun.reduce((a,b) => a+b) / avgSamplesPerRun.length;
            let max100sLength = Math.ceil(avgSampleRate * 100);
            
            if (maxLen > max100sLength) {
                console.log(`Capping maxLen from ${maxLen} to ${max100sLength} (100s limit)`);
                maxLen = max100sLength;
            }
            
            allThroughputRuns.forEach(r => {
                // Trim if exceeds maxLen
                if (r.ack.length > maxLen) r.ack = r.ack.slice(0, maxLen);
                if (r.rx.length > maxLen) r.rx = r.rx.slice(0, maxLen);
                if (r.perf.length > maxLen) r.perf = r.perf.slice(0, maxLen);
                
                // Pad to maxLen
                while(r.ack.length < maxLen) r.ack.push(null);
                while(r.rx.length < maxLen) r.rx.push(null);
                while(r.perf.length < maxLen) r.perf.push(null);
            });
            
            // Pad latency arrays to match throughput maxLen
            allLatencyRuns.forEach(r => {
                if (r.perf.length > maxLen) r.perf = r.perf.slice(0, maxLen);
                while(r.perf.length < maxLen) r.perf.push(null);
            });
            
            // Calculate mean and std for throughput
            let labels = Array.from({length: maxLen}, (_, i) => i);
            let ackMean = [], ackStd = [], rxMean = [], rxStd = [], throughputMean = [], throughputStd = [];
            
            for (let i = 0; i < maxLen; i++) {
                let ackVals = allThroughputRuns.map(r => r.ack[i]).filter(v => v != null);
                let rxVals = allThroughputRuns.map(r => r.rx[i]).filter(v => v != null);
                let throughputVals = allThroughputRuns.map(r => r.perf[i]).filter(v => v != null);
                
                ackMean[i] = ackVals.length ? ackVals.reduce((a,b) => a+b) / ackVals.length : null;
                rxMean[i] = rxVals.length ? rxVals.reduce((a,b) => a+b) / rxVals.length : null;
                throughputMean[i] = throughputVals.length ? throughputVals.reduce((a,b) => a+b) / throughputVals.length : null;
                
                ackStd[i] = ackVals.length > 1 ? Math.sqrt(ackVals.map(v => (v - ackMean[i])**2).reduce((a,b) => a+b) / ackVals.length) : 0;
                rxStd[i] = rxVals.length > 1 ? Math.sqrt(rxVals.map(v => (v - rxMean[i])**2).reduce((a,b) => a+b) / rxVals.length) : 0;
                throughputStd[i] = throughputVals.length > 1 ? Math.sqrt(throughputVals.map(v => (v - throughputMean[i])**2).reduce((a,b) => a+b) / throughputVals.length) : 0;
            }
            
            // Calculate mean and std for latency
            let latencyMean = [], latencyStd = [];
            
            for (let i = 0; i < maxLen; i++) {
                let latencyVals = allLatencyRuns.map(r => r.perf[i]).filter(v => v != null);
                
                latencyMean[i] = latencyVals.length ? latencyVals.reduce((a,b) => a+b) / latencyVals.length : null;
                latencyStd[i] = latencyVals.length > 1 ? Math.sqrt(latencyVals.map(v => (v - latencyMean[i])**2).reduce((a,b) => a+b) / latencyVals.length) : 0;
            }
            
            // Create throughput chart (no per-runNeeded)
            createChart(`Throughput (${allThroughputRuns.length} runs)`, labels, ackMean, ackStd, rxMean, rxStd, throughputMean, throughputStd, 'iperf3', null);
            // Create latency chart, pass per-run latency arrays so we can compute colored segments
            const latencyPerRuns = allLatencyRuns.map(r => r.perf);
            createChart(`Latency (${allLatencyRuns.length} runs)`, labels, ackMean, ackStd, rxMean, rxStd, latencyMean, latencyStd, 'ping', latencyPerRuns);
            
            status('Analysis complete!', 'success');
        }

        function createChart(name, labels, ackMean, ackStd, rxMean, rxStd, perfMean, perfStd, type, perRunData) {
            let wrapper = document.createElement('div');
            wrapper.className = 'chart-wrapper';
            
            let header = document.createElement('div');
            header.className = 'chart-header';
            header.innerHTML = `<div class="chart-title">${name}</div>`;
            
            let controls = document.createElement('div');
            controls.className = 'controls';
            
            let slider = document.createElement('div');
            slider.className = 'slider';
            slider.innerHTML = '<label>Smooth:</label><input type="range" min="1" max="50" value="1"><span>1</span>';
            let range = slider.querySelector('input');
            let span = slider.querySelector('span');
            controls.appendChild(slider);
            
            let legend = document.createElement('div');
            legend.className = 'legend';
            legend.innerHTML = `
                <div style="display:flex;align-items:center;gap:8px;">
                    <span style="background:#4caf50;"></span> Green &nbsp;
                    <span style="background:#ffc107;"></span> Yellow &nbsp;
                    <span style="background:#f44336;"></span> Red &nbsp;
                    <span style="background:#bdbdbd;"></span> No data
                </div>
            `;
            controls.appendChild(legend);
            
            let copy = document.createElement('button');
            copy.className = 'copy-btn';
            copy.textContent = 'üìã Copy';
            controls.appendChild(copy);
            
            header.appendChild(controls);
            wrapper.appendChild(header);
            
            let canvas = document.createElement('canvas');
            wrapper.appendChild(canvas);

            // summary container for showing colored segment ranges (text)
            let summaryDiv = document.createElement('div');
            summaryDiv.className = 'summary';
            wrapper.appendChild(summaryDiv);

            document.getElementById('charts').appendChild(wrapper);
            
            // Create std bands
            let ackUpper = ackMean.map((m, i) => m != null ? m + ackStd[i] : null);
            let ackLower = ackMean.map((m, i) => m != null ? m - ackStd[i] : null);
            let rxUpper = rxMean.map((m, i) => m != null ? m + rxStd[i] : null);
            let rxLower = rxMean.map((m, i) => m != null ? m - rxStd[i] : null);
            let perfUpper = perfMean.map((m, i) => m != null ? m + perfStd[i] : null);
            let perfLower = perfMean.map((m, i) => m != null ? m - perfStd[i] : null);
            
            // Datasets: ack band, ack mean, ack lower, rx band/mean/lower, perf band/mean/lower
            const datasets = [
                // ACK +œÉ
                { label: 'ACK SNR +œÉ', data: ackUpper, borderColor: 'rgba(102,126,234,0.25)', backgroundColor: 'rgba(102,126,234,0.08)', fill: '+1', tension: 0.4, borderWidth: 1, pointRadius: 0, yAxisID: 'y' },
                { label: 'ACK SNR Mean', data: ackMean, borderColor: '#667eea', backgroundColor: 'rgba(102,126,234,0.12)', tension: 0.4, borderWidth: 3, pointRadius: 0, yAxisID: 'y', fill: false },
                { label: 'ACK SNR -œÉ', data: ackLower, borderColor: 'rgba(102,126,234,0.25)', backgroundColor: 'rgba(102,126,234,0.08)', fill: '-1', tension: 0.4, borderWidth: 1, pointRadius: 0, yAxisID: 'y' },

                // RX +œÉ
                { label: 'RX SNR +œÉ', data: rxUpper, borderColor: 'rgba(240,147,251,0.25)', backgroundColor: 'rgba(240,147,251,0.08)', fill: '+1', tension: 0.4, borderWidth: 1, pointRadius: 0, yAxisID: 'y' },
                { label: 'RX SNR Mean', data: rxMean, borderColor: '#f093fb', backgroundColor: 'rgba(240,147,251,0.12)', tension: 0.4, borderWidth: 3, pointRadius: 0, yAxisID: 'y', fill: false },
                { label: 'RX SNR -œÉ', data: rxLower, borderColor: 'rgba(240,147,251,0.25)', backgroundColor: 'rgba(240,147,251,0.08)', fill: '-1', tension: 0.4, borderWidth: 1, pointRadius: 0, yAxisID: 'y' },

                // Performance +œÉ
                { label: (type === 'iperf3' ? 'Throughput' : 'Latency') + ' +œÉ', data: perfUpper, borderColor: 'rgba(255,107,107,0.25)', backgroundColor: 'rgba(255,107,107,0.08)', fill: '+1', tension: 0.4, borderWidth: 1, pointRadius: 0, yAxisID: 'y1' },
                { label: (type === 'iperf3' ? 'Throughput' : 'Latency') + ' Mean', data: perfMean, borderColor: '#ff6b6b', backgroundColor: 'rgba(255,107,107,0.12)', tension: 0.4, borderWidth: 3, pointRadius: 0, yAxisID: 'y1', fill: false },
                { label: (type === 'iperf3' ? 'Throughput' : 'Latency') + ' -œÉ', data: perfLower, borderColor: 'rgba(255,107,107,0.25)', backgroundColor: 'rgba(255,107,107,0.08)', fill: '-1', tension: 0.4, borderWidth: 1, pointRadius: 0, yAxisID: 'y1' }
            ];
            
            // Build status segments for latency (perRunData)
            let segmentColors = null;
            let segmentCategories = null;
            if (type === 'ping' && Array.isArray(perRunData)) {
                const maxLen = labels.length;
                segmentColors = new Array(maxLen);
                segmentCategories = new Array(maxLen);
                for (let i = 0; i < maxLen; i++) {
                    let vals = perRunData.map(r => r[i]).filter(v => v != null);
                    if (!vals.length) {
                        segmentCategories[i] = 'No data';
                        segmentColors[i] = 'rgba(189,189,189,0.06)';
                    } else if (vals.some(v => v > 75)) {
                        segmentCategories[i] = 'RED (>75ms in at least one run)';
                        segmentColors[i] = 'rgba(244,67,54,0.12)'; // red
                    } else if (vals.some(v => v > 40)) {
                        segmentCategories[i] = 'YELLOW (>40ms in at least one run)';
                        segmentColors[i] = 'rgba(255,193,7,0.12)'; // yellow
                    } else {
                        segmentCategories[i] = 'GREEN (all runs <40ms)';
                        segmentColors[i] = 'rgba(76,175,80,0.08)'; // green
                    }
                }

                // Compute contiguous ranges for summary
                const ranges = [];
                let curCat = segmentCategories[0];
                let start = 0;
                for (let i = 1; i <= segmentCategories.length; i++) {
                    if (i === segmentCategories.length || segmentCategories[i] !== curCat) {
                        ranges.push({from: start, to: i - 1, category: curCat});
                        start = i;
                        curCat = segmentCategories[i];
                    }
                }

                // Build summary text
                let summaryHtml = `<div style="margin-top:8px;"><strong>Latency segment summary:</strong></div>`;
                summaryHtml += `<pre class="segments">`;
                ranges.forEach(r => {
                    summaryHtml += `From ${r.from}s to ${r.to}s: ${r.category}\n`;
                });
                summaryHtml += `</pre>`;
                summaryDiv.innerHTML = summaryHtml;
            } else {
                // For non-latency charts clear summary
                summaryDiv.innerHTML = '';
            }
            
            const chart = new Chart(canvas, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    interaction: {mode: 'index', intersect: false},
                    plugins: {
                        legend: { display: true, position: 'top' },
                        // configure our segment background plugin only for latency charts
                        segmentBackground: {
                            enabled: type === 'ping' && !!segmentColors,
                            segments: segmentColors
                        }
                    },
                    scales: {
                        x: {
                            title: {display: true, text: 'Time (s)', font: {weight: 'bold'}}, 
                            grid: {display: false},
                            min: 0,
                            max: Math.max(...labels, 100) // ensure x max is at least number of labels or 100
                        },
                        y: {title: {display: true, text: 'SNR (dB)', font: {weight: 'bold'}}, position: 'left', grid: {display: false}},
                        y1: {title: {display: true, text: type === 'iperf3' ? 'Throughput (Mbps)' : 'Latency (ms)', font: {weight: 'bold'}}, position: 'right', grid: {display: false}}
                    }
                }
            });
            
            chartInstances.push({chart: chart, rawAckMean: ackMean, rawAckStd: ackStd, rawRxMean: rxMean, rawRxStd: rxStd, rawPerfMean: perfMean, rawPerfStd: perfStd});
            let idx = chartInstances.length - 1;
            
            range.oninput = () => {
                span.textContent = range.value;
                let w = parseInt(range.value);
                let sAckMean = smooth(chartInstances[idx].rawAckMean, w);
                let sAckStd = smooth(chartInstances[idx].rawAckStd, w);
                let sRxMean = smooth(chartInstances[idx].rawRxMean, w);
                let sRxStd = smooth(chartInstances[idx].rawRxStd, w);
                let sPerfMean = smooth(chartInstances[idx].rawPerfMean, w);
                let sPerfStd = smooth(chartInstances[idx].rawPerfStd, w);
                
                chart.data.datasets[0].data = sAckMean.map((m, i) => m != null ? m + sAckStd[i] : null);
                chart.data.datasets[1].data = sAckMean;
                chart.data.datasets[2].data = sAckMean.map((m, i) => m != null ? m - sAckStd[i] : null);
                chart.data.datasets[3].data = sRxMean.map((m, i) => m != null ? m + sRxStd[i] : null);
                chart.data.datasets[4].data = sRxMean;
                chart.data.datasets[5].data = sRxMean.map((m, i) => m != null ? m - sRxStd[i] : null);
                chart.data.datasets[6].data = sPerfMean.map((m, i) => m != null ? m + sPerfStd[i] : null);
                chart.data.datasets[7].data = sPerfMean;
                chart.data.datasets[8].data = sPerfMean.map((m, i) => m != null ? m - sPerfStd[i] : null);
                
                chart.update();
            };
            
            copy.onclick = () => copyChart(chart);
        }
    </script>
</body>
</html>
